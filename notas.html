<!-- 
LEARN NODE WITH REAL-WORLD APPLICATIONS WITH NODE JS, EXPRESSS, MONGO DB
    JOHN SMILGA / CODING ADDICT
        TEACHING STYLE
            1)general idea
            2)no slideville
            3)practical implementation to deepen understanding
        project based
            1)small project first specific topic
            2)solid understanding of moving parts
            3)big and complex project 

WHAT IS NODE JS
    Environment to run javascript out of the browser
    Created in 2009
    Built on Chromes V8 js engine
    Read, delete, update files
    Easily communicate with a database

REQUIREMENTS
    HTML,CSS,Js,ES6
    Callbacks, Promises, Async-Await

STRUCTURE
    1)familiarity with nodejs
    2)installing nodejs
    3)nodejs fundamentals 
    4)express js 
    5)after fundamentals, build node js apps

FUN FACTS
    Express provides the req and res as arguments automatically when using MVC archiquecture 
    If you invoke a function in a module, when you require that in another module, it will run the function.

LIBRARIES USED:
    1)dotenv
    2)nodemon
    3)express
    4)mongoose
    5)morgan
    6)express aysnc errors
    7)http status codes
    8)json web token 
    9)joi(not used but serves validation purposes)

SECTION 2: INSTALLING NODE --------------------------------------------------------

DIFFERENCES WITH NODEJS VS BROWSER JS
    1)NO access to browser APIs b/c they DON'T EXIST
        a)no DOM
        b)no Window API
        c)no Geolocation API
    2)Node builds Server Side Apps(Your logic)
    3)Access filesystem
        a)Info of operating system
        b)respond to network requests
    4)Based on versions
        This means that we no longer hold responsibility over uses browser version, they have to stick with our built node app v.
    6)Access to modules by default COMMON JS
    
SECTION 3: NODE BASICS -------------------------------------------------------------
HOW DOES NODE EVALUATE OUR CODE
    1)REPL
        Read, Evaluate, Print Loop
        Playing around
    2)CLI
        Running our app code in node
        Everything else

RUNNING JS FILE IN CLI 
    1)move to the path where the file is located cd "pathToFile"
    2)node fileName.js

VS CODE TERMINAL VS COMPUTER TERMINAL
    Vs code terminal is directly pointing to the project directory.
    No need to dance around the differents paths to get to the project and its files.

FINDING SOURCE CODE
    https://github.com/john-smilga/node-express-course

GLOBAL VARIABLES 
    Variables that anywhere in the application we can access. 

    1)__dirname 
        path to current directory
    2)__filename
        file name
    3)require
        function to use modules(common js)
    4)module
        info about current module(file)
    5)process
        info about env where the program is being executed

GENERAL MODULE SYNTAX
    The idea behind modules is to execute 1 file, but to split code between several files. 

    NODEjs MODULE SYSTEM
        Node uses COMMON js module system by default where every file is a module

    BENEFITS
        1)encapsulated code
            Only sharing minimum that we want 

    MODULE GLOBAL VARIABLE IN NODE
        Literally a big object that has all the info of the current module with a lot of properties:
        
        EXAMPLE
            {
                id: '.',
                path: 'C:\\Users\\enzoa\\OneDrive\\Desktop\\Node-JohnSmilga',
                exports: {},
                filename: 'C:\\Users\\enzoa\\OneDrive\\Desktop\\Node-JohnSmilga\\4-names.js',
                loaded: false,
                children: [],
                paths: [
                    'C:\\Users\\enzoa\\OneDrive\\Desktop\\Node-JohnSmilga\\node_modules',
                    'C:\\Users\\enzoa\\OneDrive\\Desktop\\node_modules',
                    'C:\\Users\\enzoa\\OneDrive\\node_modules',
                    'C:\\Users\\enzoa\\node_modules',
                    'C:\\Users\\node_modules',
                    'C:\\node_modules'
                ]
            }
            
    EXPORTING DATA FROM MODULE
        Access the exports property in the module global variable of that module to share information about it to other modules.

        EXAMPLE
            module.exports = { variable, function }
            module.exports = function

    IMPORTING DATA FROM MODULE
        1)To access the data that was exported from a module, we can import with the global variable require.
        2)we can name the import whatever we want 

        SYNTAX
            const variable = require(`./pathToFile`)
            const shakeAndBake = require)('./pathToFile')

    ALTERNATIVE WAY TO EXPORT 
        We can really work around the module.exports property and really treat it as an object.

        EXAMPLE
            module.exports.items = ['item1', 'item2']
            const person = {
                name: 'bob',

            }
            module.exports.singlePerson = person

    MIND GRENADE
        1)When requiring modules, if there exists a function invoked in that module, that function will run when being required in the other module.

        HOW THIS WORKS
            Node wraps around the module in a function, and that function runs when being invoked, which means it invokes other functions inside of it. 

BUILT IN MODULES
    Modules that node already has that can be used without any work.
        1)OS
        2)PATH
        3)FS
        4)HTTP

    OS MODULE
        The node:os module provides operating system-related utility methods and properties.

        ACCESSING OS MODULE
            const os = require('node:os');

        os.userInfo()
            Returns: <Object>

            Returns information about the currently effective user. On POSIX platforms, this is typically a subset of the password file. The returned object includes the username, uid, gid, shell, and homedir. On Windows, the uid and gid fields are -1, and shell is null.

        os.uptime()
            Returns: <integer>

            Returns the system uptime in number of seconds.

        os.type()
            Returns: <string>

            Returns the operating system name as returned by uname(3). For example, it returns 'Linux' on Linux, 'Darwin' on macOS, and 'Windows_NT' on Windows.

        os.totalmem()
            Returns: <integer>

            Returns the total amount of system memory in bytes as an integer.

        os.freemem()
            Returns: <string>

            Returns a string identifying the endianness of the CPU for which the Node.js binary was compiled.

    PATH MODULE 
        The node:path module provides utilities for working with file and directory paths. It can be accessed using:

        ACCESSING OS MODULE
            const path = require('node:path'); 

        path.sep
            Returns <string>

            Provides the platform-specific path segment separator:
                \ on Windows
                / on POSIX

        path.join([...paths])
            Returns: <string>
            
            The path.join() method joins all given path segments together using the platform-specific separator as a delimiter, then normalizes the resulting path.

        path.basename(path[, suffix])
            Returns: <string>

            The path.basename() method returns the last portion of a path.

        path.dirname(path)
            Returns: <string>

            The path.dirname() method returns the directory name of a path, similar to the Unix dirname command.

        WHY IS THIS IMPORTANT
            Our app will run in different environment, so these paths CAN NOT BE HARD CODED.
        
    FS MODULE
        The node:fs module enables interacting with the file system in a way modeled on standard POSIX functions.

        ACCESSING OS MODULE
            To use the promise-based APIs:
                const fs = require('node:fs/promises');
            To use the callback and sync APIs:
                const fs = require('node:fs');

        SYNC APPROACH
            fs.readFileSync(path[, options])
                path <string> | <Buffer> | <URL> | <integer> filename or file descriptor
                options <Object> | <string>
                Returns: <string> | <Buffer>: Returns the contents of the path.

                If the encoding option is specified then this function returns a string. Otherwise it returns a buffer.

                WHY BUFFER IS THE DEFAULT
                    1)universal binary representation: which can represent any content type(text, images, audio)
                    2)flexibility: provides max flex to the dev.
                    3)performance: Efficient by allowing direct memory manipulation for high speed data processing.
                    4)Avoids assumptions about encoding: Dev has the responsiblity to interpret the buffer correctly, safer and +flex.

            fs.writeFileSync(file, data[, options])
                file <string> | <Buffer> | <URL> | <integer> filename or file descriptor
                data <string> | <Buffer> | <TypedArray> | <DataView>
                Returns undefined.

                Creates the specified file in the path with the data.
                If file exists, it just overwrites. 

                HOW TO APPEND
                    Include 3rd options parameter.
                        {flag: 'a'}

        ASYNC APPROACH 
            fs.readFile(path[, options], callback)
                path <string> | <Buffer> | <URL> | <integer> filename or file descriptor
                options <Object> | <string>
                    encoding <string> | <null> Default: null
                    flag <string> See support of file system flags. Default: 'r'.
                    signal <AbortSignal> allows aborting an in-progress readFile
                callback <Function>
                    err <Error> | <AggregateError>
                    data <string> | <Buffer>

                Asynchronously reads the entire contents of a file.
                The callback is passed two arguments (err, data), where data is the contents of the file.
                If no encoding is specified, then the raw buffer is returned.

                EXAMPLE
                    readFile('/etc/passwd', (err, data) => {
                        if (err) throw err;
                            console.log(data);
                        }); 
                                                
            fs.writeFile(file, data[, options], callback)
                file <string> | <Buffer> | <URL> | <integer> filename or file descriptor
                data <string> | <Buffer> | <TypedArray> | <DataView>
                options <Object> | <string>
                    encoding <string> | <null> Default: 'utf8'
                    mode <integer> Default: 0o666
                    flag <string> See support of file system flags. Default: 'w'.
                    flush <boolean> If all data is successfully written to the file, and flush is true, fs.fsync() is used to flush the data. Default: false.
                    signal <AbortSignal> allows aborting an in-progress writeFile
                callback <Function>
                    err <Error> | <AggregateError>

                When file is a filename, asynchronously writes data to the file, replacing the file if it already exists. data can be a string or a buffer.
                If options is a string, then it specifies the encoding:

        SYNC VS ASYNC
            Depends on the apps requirements, regarding performance and responsiveness. 

            SYNC
                1)simple scrips or small tasks that run once.
                2)initializing code: loading config files or initial data during the startup phase of an app.
                3)debugging: can be easier to understant since it executes in a predictable manner.
                
            ASYNC
                1)servers and network apps: handling incoming requests and connections, aync prevents blocking.
                2)concurrent tasks: multiple i/o operations concurrently, async functions enable non-blocking execution.
                3)large file ops: reading or writing large files, async keeps ops responsive, avoiding delays or unresponsiveness.

    HTTP MODULE
        Brief explanation here, in depth later in next section. 

        EXPRESS
            Abstraction on top of the http module used to create:
                1)server side logic
                2)api

        http.createSever()
            Returns a new instance of http.Server.

            PARAMETERS
                Callback function
                    PARAMS
                        req = incoming request from client
                            req.url
                                Contains the URL of the incoming request.
                                Includes the path and any query string parameters WITHOUT PROTOCOL, HOST, PORT. 
                        res = what we will be sending back 
                            res.write() 
                                used to send chunk of the res body to the client and called multiple times.
                            res.end()
                                to signal you are done sending data, and close the response. 
                                Cannot call res.write() after calling res.end()
                                If res.end() is not called, client will wait forever for the response to close.

            EXAMPLE
                const http = require('node:http');

                // Create a local server to receive data from
                const server = http.createServer((req, res) => {
                res.writeHead(200, { 'Content-Type': 'application/json' });
                res.end(JSON.stringify({
                    data: 'Hello World!',
                }));
                });

                server.listen(8000);

        server.listen()
            Starts the HTTP server listening for connections. This method is identical to server.listen() from net.Server.

        EXAMPLE OF RECEIVING A REQUEST
            const http = require('http');
            const server = http.createServer((req, res) => {
                if(req.url === '/'){
                    res.end('Welcome to our home page')
                    return
                }
                if(req.url === '/about'){
                    res.end('Here is our short history')
                    return
                }
                res.end(`
                    <h1>Oops!</h1>    
                    <p>We can not seem to find the page you are looking for</p>
                    <a href="/'>back home </>
                `)

            })

            server.listen(5000)

NPM (Node package manager)
    THINK ABOUT THIS 
        Imagine you need a slider in your app. Well, someone else probably also did, and built it and left it in npm so we can use. 

    HOW TO INSTALL NPM
        NPM is Node's default package manager installed at the same time that node is installed. 

    WHAT DOES NPM ALLOW US:
        1)use our own code in other projects
        2)use other peoples code 
        3)share our own solutions with others

    WHAT CAN WE DOWNLOAD FROM NPM 
        1)libraries
        2)frameworks

    TYPICAL NODE PROJECT
        Will have more than few NPM packages installed.

    Modules        
        A module in Node.js is essentially any piece of code that can be loaded and used by other code using the require() function.

        Types of Modules:
            JavaScript File:
                If you have a JavaScript file, like example.js, you can load it as a module using require('./example'). This file is now considered a module.
            Folder with a package.json file:
                If you have a directory (folder) and it contains a package.json file, Node.js will look at the "main" field in that package.json to determine which file to load as the module.
                For example, if the package.json file contains "main": "index.js", Node.js will load index.js when the folder is required.
            Important Note:
                Not all modules are packages. A module only becomes a package when it has a package.json file. This means any JavaScript file can be a module, but to be a package, it needs that package.json file.

    Packages
        A package is a specific type of module that includes a package.json file. This package.json file contains metadata about the module, such as its name, version, entry point, dependencies, and more.
        
        Key Points About Packages:
            Package.json:
                The package.json file is the heart of a package. 
                It describes the package and provides important information that tools like npm (Node Package Manager) use to manage the package.
                
                WHY IS IT IMPORTANT
                    1)allows us to hide the node_modules when uploading repo to github 
                    2)when we clone and bring back the repo to local, it allows us to run "npm install"
                    3)npm will check the package json, see the missing dependencies and setup and install them 

            Publishing to npm:
                For a module to be published to the npm registry (a public database of packages), it must contain a package.json file. This file is essential for others to be able to install and use the package.
    
    COMMANDS TO USE IN PROJECT
        npm --version
            ASk for the specific version of npm installed
        npm i <packagaName> 
            local dependency - use only in particular project
        npm i -g <packageName>
            global dependency - use it in any project
        CREATING PACKAGE JSON
            1)npm init
                step by step approach
            2)npm init -y
                everything by default 

    COMMANDS TO UNINSTALL
        

    USING PACKAGES
        1)install package so node can find it
        2)const _ = require('<packageName')

    .gitignore
        A .gitignore file is a special file in a Git repository that tells Git which files or directories to ignore and not track. 


PUSH DIRECTORY FROM LOCAL TO GITHUB REMOTE REPO
    git init:
        Purpose: 
            Initializes a new Git repository in your local directory. This command creates a .git directory that contains the metadata and configuration for your repository.
        What If It Was Missing?: 
            Without git init, your local directory wouldn’t be recognized as a Git repository, and you wouldn’t be able to track changes, commit, or push to GitHub.

    git add .:
        Purpose: 
            Stages all changes (new, modified, and deleted files) in the current directory and its subdirectories for the next commit. The . signifies that you want to add all files in the directory.
        What If It Was Missing?: 
            If you skipped this step, your changes wouldn’t be included in the commit. The commit would only include files that were explicitly staged.

    git commit -m "Your commit message":
        Purpose: 
            Commits the staged changes to the local repository with a message describing the changes. The -m flag is used to provide a commit message inline.
        What If It Was Missing?: 
            Without committing, your changes are only staged but not recorded in the history. You would need to make another commit later to include those changes.

    git remote add origin onlinegithubrepourl.
        Purpose: 
            This command is slightly incorrect in syntax. The correct command is git remote add origin onlinegithubrepourl. It adds a remote repository named origin and links it to the URL of your GitHub repository.
        What If It Was Missing?: 
            If you don’t add a remote repository, you can’t push your local commits to GitHub. You need a remote repository to store and share your changes.

    git branch -M main:
        Purpose: 
            Renames the current branch to main. The -M flag forces the rename, even if a branch named main already exists.
        What If It Was Missing?: 
            If your GitHub repository uses main as the default branch and you don’t rename your branch, you might push to a branch with a different name, which could cause confusion or mismatched branches.

    git push -u origin main:
        Purpose: 
            Pushes your local commits to the main branch of the remote repository named origin. The -u flag sets the upstream tracking relationship, so future git push commands will default to this branch.
        What If It Was Missing?: 
            Without this push, your local commits wouldn’t be uploaded to GitHub. You would see your changes only locally, and your remote repository would remain empty.


NODEMON
    Wrapper for application in which it monitors files in project directory to restart the server automatically when it detects changes.

    GLOBAL INSTALL
        npm install -g nodemon

    DEV DEPENDENCY 
        npm install --save-dev nodemon
        npm install -D nodemon

    COMMAND TO RUN 
        nodemon app.js
    
DEV DEPENDENCIES 
    Packages or dependencies only needed during dev process. 
    Not required for the application to run in a production environment. 

    INSTALLATION
        --save-dev
        -D flag


SCRIPTS
    custom commands that can be used with npm or yarn.

    "RUN" NOT NEEDED
        start
        test
        stop
        restart


PACKAGE-LOCK.JSON
    Records the exact versions of every package installed in your project.


EVENT LOOP 
    Is what allows node to perform non - blocking I/O operations despite te fact that js is single-threaded BY offloading operations to the system kernel whenever possible.

    ORDER OF EXECUTION
        We run the immediate code first, and until that is done we run the offloaded callback. 


ASYNC PATTERNS 
    WHY
        Using callback to avoid blocking patterns can get really messy when we nest various layers deep.

    CALLBACK EXAMPLE
        const getText = (path) => {
            return new Promise((resolve, reject) => {
                readFile(path, 'utf8', (err, data) => {
                    if(err){
                        reject(err)
                        return 
                    }
                    else{
                        resolve(data)
                    }
                })
            })
        }
        
        getText('./content/second.txt')
           .then(result => console.log(result))
           .catch(err => console.log(err))

    PROMISE EXAMPLE
        const start = async () => {
            const first = await getText('./content/first.txt')
            console.log(first)
        }
        start()
        
    PROMISIY
        Is a utility that converts callback based functions into a function that returns a PROMISE.

        WHY
            Useful when working with older Node.js APIs or other callback-based functions, as it allows you to work with them using modern Js features like:
                async / await
                .then() .catch()

        HOW "PROMISIFY WORKS"
            1)callback based functions
                Many nodejs functions, especially the ones in the core module follow a pattern where the last argument is a callback function that gets called when the operation is complete.

                EXAMPLE
                    const fs = require('fs');
                    fs.readFile('path/to/file.txt', 'utf8', (err, data) => {
                        if (err) {
                            console.error(err);
                            return;
                        }
                        console.log(data);
                    });

            2)Using promisify to convert a promise based function
                The promisify function converts a function like fs.readFile into a version that returns a promise instead of using a callback.

                EXAMPLE
                    const { promisify } = require('util');
                    const fs = require('fs');

                    // Promisify the readFile function
                    const readFileAsync = promisify(fs.readFile);

                    // Use the promisified function
                    readFileAsync('path/to/file.txt', 'utf8')
                        .then(data => console.log(data))
                        .catch(err => console.error(err));

            3)Internal Workings
                1)PROMISIFY wraps the original callback in a new function that returns a PROMISE.
                2)calling the promisified function, executes the original function.


EVENT - DRIVEN PROGRAMMING
    Paradigm in which the flow of the program is determined by events such as user actions(mouse click, key presses).
    Instead of the program running a predetermined sequence, it responds to various events that occur during its execution.

    EVENTS
        Actions or ocurrence recognized by the software that may be handled by the software.
    EVENT HANDLERS
        Callback function executed in response to an event.
    EVENT LOOP
        Structure that waits for events and triggers the corresponding event handlers.
    LISTENERS
        Constructs that listen for events and specify which event handler should be invoked.


EVENT EMITTER MODULE
    Core module that provides a way to handle async events. 
    Backbone of the event-driven architecture in Node.js, enabling objects to emit events and respond to them using listeners. 
        
    EMITTING EVENTS
        An instance of 'eventEmitter' can emit named events. When an event is emitted, any listener registered for that event will be invoked.

    LISTENING TO EVENTS
        You can register listeners(callback functions) for specific events. When the event is emitted, these will be called. 

    EVENT-DRIVEN ARCHITECTURE
        The event emitter class allows node to manage async operations and inter module communications through a common interface.

    EventEmiiter.on()
        Method to attach a listener(callback function) to a specific event.
        When the event is emitted, the attached listener will be invoked. 

        SYNTAX
            eventEmitter.on(eventName, listener)

        NUMBER OF LISTENERS FOR EVENT
            We can have as many listeners as we want, and the handlers will be called in order. 

    EventEmiter.emit()
        Method to trigger an event, causing all listeners attached to that event to be called in order they were registered.

        SYNTAX
            eventEmitter.emit(eventName, [...args])
        
    EXAMPLE 
        const EventEmitter = require('events')
        const customEmitter = new EventEmitter()

        customEmitter.on('response', () => {
            console.log('data received')
        })

        customEmitter.emit('response')

    ORDER OF EXECUTION
        1)listen first
        2)emit later

    EXAMPLE 2
        myEmitter.on('event', function firstListener() {
            console.log('Helloooo! first listener');
        });
        
        myEmitter.on('event', function secondListener(arg1, arg2) {
            console.log(`event with parameters ${arg1}, ${arg2} in second listener`);
        })
        
        myEmitter.on('event', function thirdListener(...args) {
            const parameters = args.join(', ');
            console.log(`event with parameters ${parameters} in third listener`);
        });

        console.log(myEmitter.listeners('event'));

        myEmitter.emit('event', 1, 2, 3, 4, 5);

        // Prints:
            // Helloooo! first listener
            // event with parameters 1, 2 in second listener
            // event with parameters 1, 2, 3, 4, 5 in third listener

    HOW HTTP MODULE AND SERVER EMIT AN EVENT
        When a server instance is created with 'http.createServer()', this instance IS AN EVENT EMITTER that can emit events during the servers lifecycle, such as when an http request is received. 

        REQUEST EVENT
            1)http.server object emits a 'request' event every time an incoming http request is received 
            2)this event is emitted internally by the server when a client sends an http request(GET or POST) to the server.
        EVENT EMISSION IN ACTION 
            1)when the server receives a request, it triggers the 'request' event. If there is a listener attached to this, it will be called with the 'req' 'res' objects.
            2)'req' object contians information about the incoming request and 'res' object is used to end a response back to the client. 

        TWO WAYS TO CREATE A SERVER
            1)using a callback function directly 
                const http = require('http');
                const server = http.createServer((req, res) => {
                    res.end('Welcome');
                });
                server.listen(5000);

                EXPLANATION
                    1)this callback function is automatically registered as a listener for the 'request' event.
                    2)every time the server receives an http request, this callback function is invoked, 'req' and 'res' as params
                USAGE
                    1)simplicity: ideal for small apps or when you only need to handle the request event

            2)using the event emitter api 
                const http = require('http');
                const server = http.createServer();

                // Emit the 'request' event
                server.on('request', (req, res) => {
                    res.end('Welcome');
                });

                server.listen(5000);

                EXPLANATION
                    1)server is created without callback being passed.
                    2)instead, we manually attach a listener to the 'request' event using 'server.on('request', ...)'
                    3)when server receives the client http request, the 'request' event is emitted, and the attach listener is invoked.
                    4)server responds with 'welcome'

                USAGE
                    1)flexibility: we can attach multiple listeners for the same event 


STREAMS 
    Essential concept that handles reading or writing data CONTINOUSLY, typically dealing with large data sets in an efficient manner. 
    Allow to work with the data sequentially, without needing to load the entire dataset into memory at once. 

    BUFFER
        1)Temporary storage spot for a chunk of data that is being transferred from one place to another. 
        2)The buffer is filled with data, then passed along.
        3)Transfer small chunks of data at a time. 

    EXAMPLE
        Literally using buffers to transfer data and being able to stream them before they have finished loading completely. 

    USAGE
        Consume data bit by bit before it is being sent completely. 

    USEFUL FOR:
        1)handling large files
        2)network requests 
        3)other I/O operations

    TYPES IN NODE
        Writeable 
            Used to write data to a destination
        Readable
            Used to read data from a source
        Duplex
            Both readable and writable, meaning you can read and write to the same stream.
        Transform
            A type of duplex stream where the output is a transformation of the input. 

    KEY CONCEPTS 
        Chunk based Processing
            Streams process data in chunks rather than loading it all at once. This means you can start processing data before the entire dataset is available, which is more memory efficient. 
        
        Event-Driven
            Streams are instances of the 'Event-Emitter' class and emit various events during their lifecycle, such as:
                1)data
                2)end
                3)error
                4)finish

    EVENTS AND OTHER MODULES IN NODE 
        Implement streaming interface 

    EXTENDS EVENT EMITTER CLASS
        We can use events like data and end in streams.

    createReadStream()
        fs.createReadStream() is used to create a readable stream that allows you to read data from a file in chunks, rather than loading the entire file into memory.

        EXAMPLE
            const fs = require('fs');
            const readableStream = fs.createReadStream('path/to/file.txt', { encoding: 'utf8' });

        HOW IT WORKS
            1)When you create a readable stream using fs.createReadStream(), the stream begins reading the file in chunks.
            2)As each chunk is read, a 'data' event is emitted, allowing you to process the chunk.
            3)Once the entire file has been read, an 'end' event is emitted.
            4)If an error occurs during reading, an 'error' event is emitted.    

        EXAMPLE
            const fs = require('fs');

            const readableStream = fs.createReadStream('example.txt', { encoding: 'utf8' });

            readableStream.on('data', (chunk) => {
                console.log('Received chunk:', chunk);
            });

            readableStream.on('end', () => {
                console.log('No more data to read.');
            });

            readableStream.on('error', (err) => {
                console.error('An error occurred:', err.message);
            });


    createWriteStream()
        fs.createWriteStream() is used to create a writable stream that allows you to write data to a file in chunks, rather than writing it all at once.

        EXAMPLE
            const fs = require('fs');
            const writableStream = fs.createWriteStream('path/to/output.txt', { encoding: 'utf8' });

        HOW IT WORKS
            1)When you create a writable stream using fs.createWriteStream(), you can write data to the file incrementally by calling the .write() method.
            2)Once all the data has been written, you should call the .end() method to signal the end of the writing process.
            3)After calling .end(), the 'finish' event is emitted.
            4)If an error occurs during writing, an 'error' event is emitted.

        EXAMPLE
            const fs = require('fs');
            const writableStream = fs.createWriteStream('output.txt');

            writableStream.write('Hello, ');
            writableStream.write('world!\n');
            writableStream.end('This is the end.\n');

            writableStream.on('finish', () => {
                console.log('All data has been written to the file.');
            });

            writableStream.on('error', (err) => {
                console.error('An error occurred:', err.message);
            });

    HTTP STREAM EXAMPLE
        var http = require('http')
        var fs = require('fs')

        http
        .createServer(function (req, res) {
            // const text = fs.readFileSync('./content/big.txt', 'utf8')
            // res.end(text)
            const fileStream = fs.createReadStream('./content/big.txt', 'utf8')
            fileStream.on('open', () => {
            fileStream.pipe(res)
            })
            fileStream.on('error', (err) => {
            res.end(err)
            })
        })
        .listen(5000)

SECTION 4: EXPRESS 
    PROLOGUE
        GENERAL EXHANGE OF DATA ON WEB 
            1)client performs http request and sends that to server
            2)server receives the request and sends the response back to the client
        
        EXPRESS
            Abstraction on top of the http and event emitter modules to create:
                1)server side logic
                2)api 
            
        HTTP REQUEST STRUCTURE 
            1)header
                meta info
            2)body(PAYLOAD)
                optional info 
            3)method
                action on http

                TYPES
                    GET(default)
                    POST
                    PUT 
                    DELETE
            4)url
                location that receives the request
            5)remote address
                ip address returned from converting the url through the dns protocol

        SERVER
            Computer that provides service or resource to other computers, known as clients over a network. 

            SERVICES CAN BE:
                1)host websites
                2)manage databases
                3)store files 
                4)run applications

            SERVER SOFTWARE
                term server really refers to the software that runs on either a physical or virtual machine whose primary purpose is to listen for requests from clients and respond to them.

        PORT
            Numerical identifier to differentiate between types of network traffic or services running on the same server. 
            Requests are sent to a specific IP adrres and a port number.

            HOW IT WORKS
                Imagine a server as a large office building, and each port is like an office. When the request is send, the port number ensures that the request is delivered to the correct service inside the server. 

        HTTP BASICS
            const http = require('http')
                Way to import the module that will allow us to create a server

            const server = http.createServer((req, res) => {
                res.end('home page')
            })

            response.end()
                Signals to the server all of the response header and body has been sent, consider the message complete.
                MUST be called on each response. 

            req, res
                Sent by the client and we have access to manage the server side logic

        HTTP HEADERS
            res.writeHead()
                Instance of the http.ServerResponse object AND used to set status code and HTTP headers for the respone that will be send to the client.
                
                SYNTAX
                    res.writeHead(statusCode[,statusMessage][, headers])

            STATUS CODE
                3 digit number that indicates the result of the http request. 

            MIME TYPE
                Content-Type
                Content-Length
                Set-Cookie

        HTTP REQUEST OBJECT
            The request object ('req') is an instance of the 'http.IncommingMessage' class, representing the incoming HTTP request made by a client to the server. 

            req.method()
                Contains the http method used for the request, indicating the type of action client wants to perform.

            req.url()
                Contains the URL path of the request, including the query string if any.

            req.headers
                Object representing the http headers sent by the clent, each header being a key - value pair. 

            req.query
                Contains an object representing the parsed query string parameters from the url

            req.params
                Object containing route parameters

            req.body
                This property contians the parsed body of the request. 

        HTTP - HTML FILE 
            We can have an html file, and we can pass the content of the file to the client. 
            This way we avoid have to write line by line the entirety of the html.

            PROCESS
                1)separate the html content in a file
                2)read the content of the file with either of the functions of the fs module that allow for that
                3)send conent in the res object with the write()

            ERRORS
                Only the html page gets sent, no css, no images, no js file. 

                WHY
                    The html file references the other resources so the browser goes ahead and requests for them.

                SOLUTION
                    We would have to manually request ALL the files and write the if statements for the URL the browser asks for. 

            EXAMPLE
                const http = require('http')
                const {readFileSync} = require('fs')

                //get all files
                const homePage = readFileSync('./navbar-app/index.html')
                const homeStyles = readFileSync('./navbar-app/styles.css')
                const homeImage = readFileSync('./navbar-app/logo.svg')
                const homeLogic = readFileSync('./navbar-app/browser-app.js')


                const server = http.createServer((req,res) => {
                    //console.log(req.method)
                    const url = req.url
                    //home page
                    if(url == '/'){
                        res.writeHead(200, {'content-type': 'text/html'})
                        res.write(homePage)
                        res.end()
                    }
                    //about page 
                    else if(url === '/about'){
                        res.writeHead(200, {'content-type': 'text/html'})
                        res.write('<h1>about page</h1>')
                        res.end()
                    }
                    //styles
                    else if(url === '/styles.css'){
                        res.writeHead(200, {'content-type': 'text/css'})
                        res.write(homeStyles)
                        res.end()
                    }
                    //image/logo
                    else if(url === '/logo.svg'){
                        res.writeHead(200, {'content-type': 'image/svg+xml'})
                        res.write(homeImage)
                        res.end()
                    }
                    //js logic
                    else if(url === '/browser-app.js'){
                        res.writeHead(200, {'content-type': 'text/javascript'})
                        res.write(homeLogic)
                        res.end()
                    }
                    //404
                    else{
                        res.writeHead(404, {'content-type': 'text/html'})
                        res.write('<h1>404 resource not found</h1>')
                        res.end()
                    }
                })

                server.listen(5000)

    EXPRESS BASICS
        Minimal and flexible node.js web application framework that provides a robust set of features for web and mobile applications. 

    APIs
        Miriad of HTTP utility methods and middleware at your disposal, creating a robust API is quick and easy.

    PERFORMANCE
        Thin layer of fundamental web application features, without obscuring Node.js features that are loved by the community. 

    MOST USED EXPRESS METHODS
        app.get
        app.post
        app.put
        app.delete
        app.all
        app.use
        app.listen

    BASIC ROUTING
        Refers to how an app responds to a client request to a particular endpoint:
            1)specific URI
            2)specific HTTP request method 

        SYNTAX
            app.METHOD(path handler)

        WHERE:
            APP:Instance of express
            METHOD: htpp request method
            PATH: path on the server
            HANDLER: function executed when route is matched
    
        EXAMPLES
            app.get('/', (req, res) => {
                res.send('Hello World!')
            })
            
            app.post('/', (req, res) => {
                res.send('Got a POST request')
            })

            app.put('/user', (req, res) => {
                res.send('Got a PUT request at /user')
            })

            app.delete('/user', (req, res) => {
                res.send('Got a DELETE request at /user')
            })

    res.send()
        Used to send a response back to the client. 

        Automatic Content-Type: 
            If you send a string, Express sets the Content-Type to text/html. If you send an object or array, it sets Content-Type to application/json.
        Response Termination: 
            res.send() ends the response process, so you don't need to call res.end() afterward.
        Chaining: 
            You can chain other response methods like res.status() before res.send() to set the HTTP status code.

            EXAMPLE
                res.status(200).send('Success')

    BASIC EXPRESS APP
        res.sendFile()
            Used to send a file as an http response to the client. Particularly useful when you need to serve static files like HTML, images, PDFs, or any other type of file stored on your server.

            EXAMPLE
                const express = require('express');
                const path = require('path');
                const app = express();

                app.get('/file', (req, res) => {
                    const filePath = path.join(__dirname, 'public', 'example.pdf');
                    res.sendFile(filePath);
                });

                app.listen(3000, () => {
                    console.log('Server is running on port 3000');
                });
            
            ABSOLUTE PATH
                res.sendfile() requires an absolute path to the file.

                If using relative path, create absolute path with:
                    1)path.join()
                    2)path.resolve()

            CONTENT-TYPE
                Express automatically sets the 'Content-Type' header based on the file's MIME type. 

            ERROR HANDLING
                If the file does not exist or theres an error in sending it, express will auto handle it and send 404 or 500 response until specified otherwise. 

        NODE BUILT IN DEFAULT DIRECTORY METHODS
            Methods provided by nodes built in path module, which help work with file and directory paths in a way THATS PLATFORM INDEPENDNENT. 

            path.join()
                Combines multiple path segments into a single path. Normalizes the resulting path, handling any redundant separators(slashes) or relative segments(.. or .)
                

            path.resolve()
                Resolves a sequence of paths or path segments into an absolute path. Starts by working from the last parameter, to the last on the left, combining each segment along the way. 

                If no absolute path is provided, path.resolve() will use the current working directory as the starting point. 

                EXAMPLE
                    const path = require('path');
                    const resolvedPath = path.resolve('users', 'john', 'documents', 'file.txt');
                    console.log(resolvedPath);
                    // Output: '/current/working/directory/users/john/documents/file.txt'
                
            DIFFERENCES
                1).join() simply concatenates and normalizes while resolve() always returns and absolute path.
                2).resolve() uses current directory while .join() does not
            
        DEALING WITH STATIC ASSETS IN EXPRESS
            app.use(express.static()) middleware in Express.js is used to serve static files such as: 
                1)HTML
                2)CSS
                3)JAVASCRIPT
                4)IMAGES
                
            HOW IT WORKS
                1)Express will look in the specified directory for any requested file. If it is found, will serve it directly without needing addiotional logic.
                2)The path specified is relative to the directory from which the node process launches
                3)If a request matches a file within the static directory, express will serve that file. If not, will continue for another route or middleware to handle the request. 

        SPECIFICALLY DEALING WITH SENDING INDEX.HTML
            1)Adding file to static assets
            2)Server Side Rendering

    API VS SSR
        API
            http interface to interact with data
            JSON()
                data format to send information from the api 
            res.json()

        SSR
            Send entire html and js template
            res.render()

    JSON - BASICS
        res.json(body)
            Sends a JSON response. This method sends a response that is the parameter converted to a JSON string using JSON.stringify()

    ROUTE PARAMS
        Route parameters are named URL segments that are used to capture the values specified at their position in the URL. The captured values are populated in the req.params object, with the name of the route parameter specified in the path as their respective keys.

        EXAMPLE
            Route path: /users/:userId/books/:bookId
            Request URL: http://localhost:3000/users/34/books/8989
            req.params: { "userId": "34", "bookId": "8989" }

    QUERY STRING PARAMS
         They are used to filter, sort, customize or provide additional options for a request. 
         Multiple query parameters can be separated by an ampersand (&).
         
         EXAMPLE SERVER ENDPOINT
            pp.get('/search', (req, res) => {
                const query = req.query.q;
                const page = req.query.page;
                res.send(`Search query: ${query}, Page: ${page}`);
            });

        EXAMPLE CLIENT REQUEST URL 
            http://localhost:3000/search?q=nodejs&page=2

        CAPTURED IN EXPRESS
            const query = req.query.q;    // "nodejs"
            const page = req.query.page;  // "2"

    DIFFERENCES BETWEEN ROUTE PARAMETERS AND QUERY PARAMETES
        Position in URL:
            Route Parameters are part of the URL path itself (e.g., /users/123).
            Query Parameters are appended to the URL after a question mark (e.g., /search?q=nodejs&page=2).
        Purpose:
            Route Parameters are used to define specific resources (like identifying a user by ID).
            Query Parameters are used to refine or filter the results of a resource (like searching or paginating results).
        Express Access:
            Route Parameters are accessed using req.params.
            Query Parameters are accessed using req.query.

    Example Combined Use Case:
        app.get('/users/:userId/posts', (req, res) => {
            const userId = req.params.userId;  // Route parameter
            const sortBy = req.query.sortBy;   // Query parameter
            const limit = req.query.limit;     // Query parameter
            res.send(`User ID: ${userId}, Sort By: ${sortBy}, Limit: ${limit}`);
        });

    MIDDLEWARE
        Functions that execute during the http request-response cycle and have access to:
            1)request object
            2)response object
            3)next middleware function

        They can:
            1)execute any code
            2)make changes to the request and response objects
            3)end the request - response cycle
            4)call the next middleware function

        Practical uses for middleware:
            1)logging
            2)authentication
            3)data parsing

        Without middleware:
            Any change made to the req object would have to be handled in EVERY SINGLE ROUTE.

        Usefulness:
            1)code reusability:
                Allows to reuse code across different routes 
            2)modularity:
                Breaks down logic into smaller reusable components.
            3)Request Lifecycle management
                Modify request response objects, stop cycle, pass control of cycle to next function
            4)Error Handling
                Catch and handle erros throughout the application, consistent way to manage errors and responses.
            5)security
                adding sec features

        SYNTAX 
           function middlewareFunction(req, res, next) {
                // Perform operations here
                next(); // Pass control to the next middleware
            }

        TYPES OF MIDDLEWARE FUNCTIONS:
            Application-Level Middleware
                1)defined directly on the 'app' object using app.use() or app.METHOD()
                2)Can be executed for every request to the app or for specific routes

                EXAMPLE
                    const express = require('express');
                    const app = express();

                    app.use((req, res, next) => {
                            console.log('Time:', Date.now());
                        next(); // Pass control to the next middleware function
                    });

                    app.get('/', (req, res) => {
                        res.send('Home Page');
                    });

                    app.listen(3000);

            Router Level Middleware:
                1)Works similarly to application - level middleware but is bound to an instance of express.Router()
                
                EXAMPLE
                    const express = require('express');
                    const router = express.Router();

                    router.use((req, res, next) => {
                        console.log('Request URL:', req.originalUrl);
                        next();
                    });

                    router.get('/', (req, res) => {
                        res.send('Router Home');
                    });

                    const app = express();
                    app.use('/router', router);

                    app.listen(3000);

            Built in Middleware:
                Express comes with several built-in middleware functions such as:
                    1)express.static(): For serving static files
                        Purpose: 
                            Serves static files, such as HTML files, CSS files, images, and JavaScript files, from a specified directory.
                    2)express.json(): For parsing JSON
                        Purpose: 
                            Parses incoming requests with JSON payloads and makes the data available in req.body.
                    3)express.urlencoded() for parsing URL-encoded data
                        Purpose: 
                            Parses incoming requests with URL-encoded payloads (like form submissions) and makes the data available in req.body.
                        Options:
                            extended: true: 
                                Allows for rich objects and arrays to be encoded into the URL-encoded format, using the qs library. This is generally recommended.
                            extended: false: 
                                Uses the querystring library to parse URL-encoded data, which does not support nested objects.

            Third Party Middleware:
                You can install and use middleware provided by third parties, such as 'morgan' or 'helmet' for security

                EXAMPLE
                    const morgan = require('morgan')
                    app.use(morgan('tiny')) log http requests 

            Error - Handling Middleware:
                Special middleware that handles errors with arguments: err, req, res, next.

                EXAMPLE
                    app.use((err, req, res, next) => {
                        console.error(err.stack);
                        res.status(500).send('Something broke!');
                    });

        ENDING REQUEST CYCLE
            Without one of the following functions called in the middleware, the request - response cycle will continue forever. 
            1)res.send()
            2)next()

        app.use()
            By using app.use(), you can apply middleware globally across all routes in your application. This ensures that certain tasks (e.g., logging, authentication) are consistently performed for every request, regardless of the specific route.

            2. Order of Execution
                app.use() allows you to define the order in which middleware functions are executed. Since middleware functions are executed in the order they are added, you can strategically place them to ensure that specific operations are performed at the right time in the request-response cycle.

                EXAMPLE
                    app.use(authMiddleware);
                    app.use(loggingMiddleware);
                    app.use(errorHandlingMiddleware);

            3. Path-Specific Middleware
                You can use app.use() to apply middleware to specific routes or paths, rather than the entire application. This allows you to tailor the behavior of your app based on the requested URL.

                EXAMPLE
                    app.use('/admin', adminMiddleware); // Applies to all routes under /admin
                    app.use('/api', apiMiddleware);     // Applies to all routes under /api 

            4. Preprocessing Requests
                Middleware registered with app.use() can preprocess incoming requests before they reach the route handlers. This Includes parsing JSON bodies, URL-encoded data, or performing other transformations on the req and res objects.

                EXAMPLES
                    app.use(express.json()); // Parse incoming JSON requests
                    app.use(express.urlencoded({ extended: true })); // Parse URL-encoded dat

        MORGAN MIDDLEWARE 
            Morgan is a popular HTTP request logger middleware for Node.js applications, typically used with Express.js. It helps you log details about incoming requests to your server, which can be invaluable for debugging, monitoring, and analyzing traffic.

            Key Features of Morgan
                Customizable Formats:
                    Morgan offers various predefined logging formats like combined, common, dev, short, and tiny. These formats determine how the logs will be structured and what information will be included.
                Custom Tokens: 
                    You can define custom tokens to include specific information in the logs.
                Flexible Output: 
                    Logs can be directed to different outputs, such as the console, a file, or even a logging service.
                Stream Support: 
                    Morgan allows you to specify a stream where the logs should be written, giving you control over where the logs are stored.

    MVC 
        MVC stands for Model-View-Controller. It's a software architectural pattern used for designing web applications, separating the application into three interconnected components. This separation helps manage complexity, organize code, and maintain scalability. Here's a breakdown of each component:

        1. Model:
            What It Does: 
                The Model represents the data and the business logic of the application. It handles data-related operations such as fetching data from a database, processing it, and returning it to the controller.
            Example: 
                In a blogging application, the Model would represent entities like Post, Comment, or User. It might include methods to save a new post to the database or retrieve all comments associated with a particular post.

        2. View:
            What It Does: 
                The View is responsible for presenting data to the user. It generates the user interface (UI) based on the data provided by the Model, typically in the form of HTML, CSS, and JavaScript.
            Example: 
                Continuing with the blogging application, the View would be the part that generates the web page displaying a blog post and its comments. It formats the data received from the Model into a readable and visually appealing format.
            3. Controller:
            What It Does: 
                The Controller acts as an intermediary between the Model and the View. It handles user input, manipulates data through the Model, and sends the appropriate data back to the View. Essentially, it processes incoming requests, applies the necessary business logic, and returns the appropriate response.
            Example: 
                In our blogging application, if a user submits a new comment, the Controller will receive the data from the user's request, use the Model to save the comment to the database, and then redirect the user back to the post's View with the updated list of comments.

        How MVC Works Together:
            Flow: 
                When a user interacts with a web application (e.g., clicking a button or submitting a form), the request is first handled by the Controller.
            Controller: 
                The Controller processes the user input, interacts with the Model if necessary, and decides which View to render.
            Model: 
                The Model performs data operations, such as fetching, updating, or deleting data, and sends the results back to the Controller.
            View: 
                The Controller passes the data to the View, which then generates the appropriate UI for the user.

        Benefits of Using MVC:
            Separation of Concerns: 
                Each component has a distinct role, making the application easier to manage and scale.
            Maintainability: 
                Changes to the user interface (View) can be made independently of the business logic (Model).
            Testability: 
                Because components are separate, it’s easier to test each part in isolation

        Example in a Web Application:
            Imagine you're building a to-do list application:

            Model: 
                Defines a Task object with attributes like title, description, dueDate, and methods to save, delete, or update tasks.
            View: 
                Displays the list of tasks to the user and provides a form to add or edit tasks.
            Controller: 
                Handles user actions like adding a new task, marks a task as complete, or deletes a task. It interacts with the Model to update the data and then updates the View to reflect these changes.
                    
    express.router()
        Use the express.Router class to create modular, mountable route handlers. A Router instance is a complete middleware and routing system; for this reason, it is often referred to as a “mini-app”.
        
        The following example creates a router as a module, loads a middleware function in it, defines some routes, and mounts the router module on a path in the main app.

        EXAMPLE
            const express = require('express')
            const router = express.Router()

            // middleware that is specific to this router
            const timeLog = (req, res, next) => {
            console.log('Time: ', Date.now())
            next()
            }
            router.use(timeLog)

            // define the home page route
            router.get('/', (req, res) => {
            res.send('Birds home page')
            })
            // define the about route
            router.get('/about', (req, res) => {
            res.send('About birds')
            })

            module.exports = router

            const birds = require('./birds')
            // ...

            app.use('/birds', birds)

    app.route()
        You can create chainable route handlers for a route path by using app.route(). Because the path is specified at a single location, creating modular routes is helpful, as is reducing redundancy and typos. For more information about routes, see: Router() documentation.

        EXAMPLE
            app.route('/book')
            .get((req, res) => {
                res.send('Get a random book')
            })
            .post((req, res) => {
                res.send('Add a book')
            })
            .put((req, res) => {
                res.send('Update the book')
            }) 


SECTION 6: TASK MANAGER API 
    GOALS
        1)Setup and connect to cloud database to persist data
        2)Learn CRUD operations on data
        
    WHY /API/V1 CONVENTION?
        Separation of concerns: 
            Helps differentiate between routes that serve the web application pages, assets like images and Styles and routes that serve the API.

        Clarity: 
            Provides clear indication to devs and users that the route is related to the api and can tell that it is meant to return data, not a web page. 

        EXAMPLE
            domain/api/version/endpoint

    GLOBAL VARIABLES IN POSTMAN 
        In essence, global variables reduce redundancy, minimize errors, and streamline the workflow, making it easier to manage large and complex API testing projects.

        EXAMPLE
            {{baseUrl}}/users

    REST API 
        Representational State Transfer, most common API design pattern that determines how data looks like. 
        HTTP interface in which other apps, most likely front end ones, can interact with out data. 

        Combines:
            HTTP verbs
            Route paths
            Resources

    TRY - CATCH
        Crucial tools for handling errors when working with async operations such as: fetching data from api, reading files, interacting with database.

        WHY?
            Unhandled async errors might lead to crashes in the application or leave an unpredictable state. 

    MONGO-DB 
        1)NoSQL, NON Relational DB
        2)Store JSON - does not care how data relates
        3)collections instead of tables
        4)documents instead of rows(single object)
        5)easy to get started
        6)free cloud hosting - atlas

        Mongo DB Atlas
            MongoDB Atlas is a fully-managed cloud database service for MongoDB, the popular NoSQL database. 

            WHY USEFUL
                Time-Saving: 
                    No need to manage the underlying infrastructure. MongoDB Atlas handles everything from provisioning to backups and scaling.
                Reliability: 
                    Built-in features like replication, backups, and monitoring help ensure the reliability and stability of your databases.
                Performance: 
                    With auto-scaling and global data distribution, MongoDB Atlas is optimized for high performance across different geographies.
                Focus on Development: 
                    You can concentrate on building applications while Atlas handles database management.

        INITIAL SETUP
            1)create account
            2)set cluster
            3)set database
            4)set user permission
            5)set network permission
            6)create collection
            7)create documents 

        SCHEMA IN MONGO 
            Dynamic
                Documents in a same collection don't need to have the same structure schema.

        MONGOOSE
            Mongoose is an Object Data Modeling (ODM) library for MongoDB and Node.js. 
            
            It provides a schema-based solution for modeling your data and helps you interact with MongoDB in a more structured and organized way, especially when working with complex data models.

            Why Mongoose is Useful:
                Schema Enforcement:
                    MongoDB is schema-less, which offers flexibility but can lead to inconsistent data structures. Mongoose enforces schemas, bringing structure and order to your data, making it easier to manage in the long term.
                Validation
                    Data validation is built into Mongoose, reducing the need to manually check data integrity in your application logic. This reduces errors and increases data consistency.
                Easier Data Manipulation:
                    Mongoose abstracts away a lot of the lower-level complexity involved with interacting with MongoDB. Its query building, schema enforcement, and document manipulation methods make working with MongoDB easier and less error-prone.
                Support for Middleware:
                    Mongoose’s middleware (hooks) helps with automating workflows, such as hashing passwords before saving user data or triggering specific actions after updating a document.
                Relationships and Population:
                    While MongoDB doesn’t natively support relationships like a relational database, Mongoose enables you to model and query relationships between documents in a clean and efficient way.
                Object-Oriented Approach:
                    Mongoose takes an object-oriented approach to interacting with MongoDB. It allows developers to model their data in a way that’s closer to how they structure their application logic, making the data more intuitive to work with.
                Community and Ecosystem:
                    Mongoose has a large community and a mature ecosystem, with extensive documentation and third-party packages, which means you'll have good support when working on projects.
            
            ORDER OF CONNECTION 
                Makes no sense to connect to the server and then to connect to the database.

                Should be:
                    1)connect to db
                    2)only then, connect to server

            SCHEMA
                The configuration object for a Mongoose model
                Everything in Mongoose starts with a Schema. 
                Each schema maps to a MongoDB collection and defines the shape of the documents within that collection.

                EXAMPLE
                    import mongoose from 'mongoose';
                    const { Schema } = mongoose;

                    const blogSchema = new Schema({
                    title: String, // String is shorthand for {type: String}
                    author: String,
                    body: String,
                    comments: [{ body: String, date: Date }],
                    date: { type: Date, default: Date.now },
                    hidden: Boolean,
                    meta: {
                        votes: Number,
                        favs: Number
                    }
                    });

            MODEL
                Models are fancy constructors compiled from Schema definitions. 
                An instance of a model is called a document. 
                Models are responsible for creating and reading documents from the underlying MongoDB database.

                ModelName = Singular name of the collection model is for. Mongoose looks for the plural lowercase

                SYNTAX
                    mongoose.model(modelName, Schema)

                EXAMPLE
                    const schema = new mongoose.Schema({ name: String, size: String });
                    const Tank = mongoose.model('Tank', schema);

                CONSTRUCTING MODEL 
                    An instance of a model is called a document. Creating them and saving to the database is easy.

                    EXAMPLE
                        await Tank.create({ size: 'small' });


            SCHEMATYPES
                 A SchemaType is then a configuration object for an individual property. 

                WHAT DOES IT HANDLE
                    SchemaTypes handle definition of path defaults, validation, getters, setters, field selection defaults for queries, and other general characteristics for Mongoose document properties.

                MOST SCHEMA TYPES
                    required: 
                        boolean or function, if true adds a required validator for this property
                    default: 
                        Any or function, sets a default value for the path. If the value is a function, the return value of the function is used as the default.
                    select: 
                        boolean, specifies default projections for queries
                    validate:
                        function, adds a validator function for this property
                    get: 
                        function, defines a custom getter for this property using Object.defineProperty().
                    set: 
                        function, defines a custom setter for this property using Object.defineProperty().
                    alias: 
                        string, mongoose >= 4.10.0 only. Defines a virtual with the given name that gets/sets this path.
                    immutable: 
                        boolean, defines path as immutable. Mongoose prevents you from changing immutable paths unless the parent document has isNew: true.
                    transform: 
                        function, Mongoose calls this function when you call Document#toJSON() function, including when you JSON.stringify() a document.

                VALIDATIONS
                    At the moment the schema allows empty properties and empty objects. 

                    Validation is defined in the SchemaType
                    Validation is middleware. Mongoose registers validation as a pre('save') hook on every schema by default.

                    REQUIRED
                        Validation in the schema that states that a property can't be empty. 

                        SYNTAX
                            property: {
                                type: String,
                                required: [true, 'custom Error Message To Show']
                            }

                    TRIM
                        Removes empty spaces from a value in a specific property 

                        SYNTAX
                            property: {
                                type: String,
                                trim: true
                            }

                    MIN - MAX PROPERTIES
                        Allows to specify the min and max values allowed for a property.

                        SYNTAX
                            property: {
                                type: String,
                                maxlength: [20, "custom error message"] 
                            }


                FINDING ALL OBJECTS
                    Finds documents.

                    Mongoose casts the filter to match the model's schema before the command is sent. 

                    // find all documents
                    await MyModel.find({});

                    // find all documents named john and at least 18
                    await MyModel.find({ name: 'john', age: { $gte: 18 } }).exec()

                FIND BY ID
                    Finds a single document by its _id field. findById(id) is almost* equivalent to findOne({ _id: id }). If you want to query by a document's _id, use findById() instead of findOne().

                FINDONE
                    Finds one document.
                    Note: conditions is optional, and if conditions is null or undefined, mongoose will send an empty findOne command to MongoDB, which will return an arbitrary document. If you're querying by _id, use findById() instead.

                    // Find one adventure whose `country` is 'Croatia', otherwise `null`
                    await Adventure.findOne({ country: 'Croatia' }).exec();

                FINDONEANDDELETE
                FINDONEANDUPDATE

    DOTENV 
        Using dotenv is a common way to manage environment variables in Node.js applications. This is especially useful for keeping sensitive information like API keys, database credentials, and other configuration settings out of your source code.

        require('dotenv').config();
            This will load all the variables from the .env file into process.env.

        You can now access these variables anywhere in your code using process.env. For example:
            const mongoose = require('mongoose');

            mongoose.connect(process.env.DATABASE_URL, {
            useNewUrlParser: true,
            useUnifiedTopology: true,
            })
            .then(() => console.log('Connected to MongoDB'))
            .catch((err) => console.error('Failed to connect to MongoDB', err));

            const port = process.env.PORT || 3000;
            app.listen(port, () => {
            console.log(`Server running on port ${port}`);
            });

    ERROR HANDLING EXPRESS
        Express comes with a built-in error handler that takes care of any errors that might be encountered in the app. 
        This default error-handling middleware function is added at the end of the middleware function stack.

        If you pass an error to next() and you do not handle it in a custom error handler, it will be handled by the built-in error handler; the error will be written to the client with the stack trace. The stack trace is not included in the production environment.

    THROW
        1)Generates an expection
        2)Halts the curren functions
        3)Handles control to the nearest catch(handles exceptions)

    SUMMARY
        FOLDERS NEEDED IN STRUCTURE
            1)db
                1)connect
            2)routes
                1)specific routers
            3)controllers
                1)specific controllers
            4)models
                1)specific models
            5)middleware
                1)not found
                2)error handling 
                3)async
            6)errors
                custom error


SECTION 7: STORE API 
        OBJECTIVE
            Offer filtering options to the user

            EXAMPLE
                algolia.com api 

    EXPRESS ASYNC ERRORS
        Simplifies error handling in express

        WHY?
            Normally when errors occur in async handlers in express, the errors are not caught automatically by express's error handling middleware. 

        BAD SOLUTION
            Wrap every handler in a try / catch 

        HOW EXPRESS ASYNC ERRORS WORKS 
            auto catches the errors and passes them to express's error handling middleware, without needing to wrap everything in try catch. 
        
        THE MAGIC INSIDE
            wraps all async route handlers. Detecs when a promise is rejected or error thrown the async route handler. 
            It ensures it is being passed to the handler with has the err parameter. 

    DEFINED MODEL
        enum

    .CREATE()
        Property accepts a single object and an array of objects

    POPULATED DB 
        promises
        process.exit()

    Moddel.find()
        used to retrieve documents based on the provided query.

        BASIC SYNTAX
            Model.find(query, [projection], [options], [callback])

        PARAMETERS
            1)query
                Defines the conditions for selecting documents based on key value pairs\

                a)basic 
                    Model.find({name: 'john'})
                b)query operators mongoDB
                    Model.find({age: {$gt:18}})

            2)projection
                Specifies whether to include or exclude from the result. 
                    Model.find({}, {name: 1, age:1})

            3) options
                allows you to specify additioinal options to control the query's behavior.
                limit
                skip
                sort
                lean

    QUERY PARAMS
        Using req.query obj as the options object to find in the db.
            const products = await Product.find(req.query) //empty object makes no difference 

        USE? 
            Can search from the db dynamically with the re.query object

    MONGOOSE V6 UPDATE
        Mongoose will filter out properties that are not in the schema. 
        Previously used to return an empty [], now it just filters the properties out. 

    SCHEMA VS NON SCHEMA
        Mongoose gives a pre determined schema to the collection, enforcing the schema to be respected, and b/c of this it ignores properties that are not in the schema.

    REFACTOR TO QUERY OBJECT
        WHY?
            This will allow us to extract the properties we will need and act based upon which properties we are receiving instead of just being affected by 1 property that will not be of use.

        COMPANY
            Same process as with feature

        NAME
            PROBLEM
                It will only find the name that matches exactly the same 

            QUERY OPERATORS MONGODB
                REGEX
                    Using a string pattern to search everything that may include tha search 
                $regex
                    Provides regular expression capabilities for pattern matching strings in queries.

                SYNTAX
                    { <field>: { $regex: /pattern/, $options: '<options>' } }
                    { "<field>": { "$regex": "pattern", "$options": "<options>" } }
                    { <field>: { $regex: /pattern/<options> } }

                This creates a query where:
                    name is matched using a regular expression specified by $regex: name, which will search for any occurrence of the string provided in the name field.
                    The $options: 'i' flag tells MongoDB to perform the match in a case-insensitive manner.

    SORTING DATA
        Is how to ensure your query results come back in the desired order

        MONGOOSE EXAMPLES
            // sort by "field" ascending and "test" descending
            query.sort({ field: 'asc', test: -1 });

            // equivalent
            query.sort('field -test');

            // also possible is to use a array with array key-value pairs
            query.sort([['field', 'asc']]);

        HOW DOES IT WORK
            By chaining to the promise that the original find method of the model returns. 

        SIMPLE MONOGOOSE EXAMPLE
            await Person.find({}).sort({age: -1})
            awair Product.find({}).sort('-name price')

        SORTING MULTIPLE FIELDS 
            The order of the keys determines what key MongoDB server sorts by first. 
            
            EXAMPLE
                await Person.find().sort({age:1, weight: -1})

        LAZY EVALUATION
            Computation of a value, is deferred until the result is actually needed. 

            QUERY OBJECT CREATION
                Product.find(queryObject) just describes what you want to receive from the database, but does not run the query.
                It lets you refine the query before actually runinng it by adding further modifiers. 
            CHAINING MODIFIERS
                Every method added further refines the query object that will eventually run to the database.
            QUERY EXECUTION
                finally mongoose takes the query object and executes it against a database
                sends the query to the database 
                retrieves the result and returns them

            BENEFITS
                flexibility
                performance
                readability


    SELECT OPTION
        Specifies which documents to include or exclude.

        STRING SYNTAX
             -: will flag path as excluded
            "": when a path does not have a prefix, it is included.
            + :forces inclusion of the pat.

        HOW TO TELL USER IN API DOCS
            It is up to us to choose how we call the field that the user will use to select the properties to recieve back.

        EXAMPLE
            if(fields){
                let fieldsList = fields.split(',').join(' ')
                result = result.select(fieldsList)
            }

    SKIP AND LIMIT 
        SKIP(usuallty called offset)
            number of records to skip before the next stage

            SYNTAX
                aggregate.skip(10)

        LIMIT
            maximum number of records to return

            SYNTAX
                aggregate.limit(10);

    PAGINATION
        Usually done by combining skip and limit

        EXAMPLE
            const page = Number(req.query.page) || 1 // if no page requested, duh it is one. 
            const limit = Number(req.query.limit) || 10 // normally default.
            const skip = (page - 1) * limit 
            result = result.skip(skip).limit(limit)

    NUMERIC FILTER
        PURPOSES
            Let the user find a product based on a numeric filter on the price property 

        HOW MONGOOSE HANDLES IT
            Every time you want to filter based on a value, like a logical expression, you would be best to use a regex.    

        EXAMPLE OF API TO MIMIC
            numericFilters = <,<=,=,>,>= for the properties => created_at_i, points, num_comments 

        Step-by-Step Execution:
            Replace Operators:
                "price>100,rating>=4" becomes "price-$gt-100,rating-$gte-4".
            Split into Filters:
                filters becomes ["price-$gt-100", "rating-$gte-4"].
            Processing Each Filter:
                For "price-$gt-100":
                    field = "price", operator = "$gt", value = "100".
                    Since "price" is in options, queryObject["price"] = { "$gt": 100 }.
                For "rating-$gte-4":
                    field = "rating", operator = "$gte", value = "4".
                    Since "rating" is in options, queryObject["rating"] = { "$gte": 4 }.
            Final queryObject:
                {
                    price: { $gt: 100 },
                    rating: { $gte: 4 }
                }


SECTION 8: JWT - BASICS
    WHAT TO LEARN:
        1)jwt basics
        2)importance of authentication 
        3)how to manage server logic for authorization 

    BASIC IDEA
        If token is present in request, user can access specific info.

    VALIDATE USERNAME AND PASSWORD
        1)check request body for username and password
        2)if data exists in db create jwt, if not error reponse 
        3)send data back to front end

        WAYS TO VALIDATE BODY
            1)mongoose 
            2)Joi
            3)check in controller
                    
        
    JWT OVERVIEW
        WHY USE JWT
            1)Security feature(it means its the same token sent to the front end)
            2)server does not remember every single request sent
            3)size is smaller than with other tokens

        JWT STRUCTURE
            header
            payload
            signature

            HEADER
                type of the token
                    jwt
                algorithm used
                    hmac
                    sha256
                    rsa
            PAYLOAD
                information from the client 
            SIGNATURE
                Special key that only the back end knows and sends back, if the backend does not receive the token with the exact signature then it will not work. 
            
        JSONWEBTOKEN PACKAGE
            SETUP
                const jwt = require('jsonwebtoken');
                const token = jwt.sign({username},process.env.JWT_SECRET, {expiresIn:'30d'})

            jwt.sign() accepts 3 parameters:
                Payload
                    Data to include in the JWT.
                    This can be any information you want to store or transmit securely, such as user:
                        ID
                        email
                        roles 
                Secret or private key
                    String used to sign the token. 
                    On the server side you use this key to both sign the token and verify its authenticity later.
                Options(optional)
                    Set additional metadata for the token, such as its expiration time, issuer, audience, and algorithm to use for signing.
                        expiresIn
                        issuer
                        audience
                        algorithm

                EXAMPLES OF HOW TO CREATE TOKEN 
                    jwt.sign({data: 'foobar'}, 'secret', { expiresIn: 60 * 60 });

                    //or even better:
                        jwt.sign({data: 'foobar'}, 'secret', { expiresIn: '1h' });

                WHY THE PAYLOAD
                    Provide the back end with useful verifiable information without the need to query the database or another system for each request.

                    Stateless auth
                        The back end retains ntohing of the request, the payload allows for authentication without querying a database system.

                    Efficiency
                        Avoid repeated database lookups.

                HOW DOES THE BACK END USE THE PAYLOAD
                    1)Verifying the identity: checking id
                    2)Authorization: checking role
                    3)Expiration Handling: expiration 

        HOW TO INCLUDE TOKEN FROM THE FRONT END REQUEST
            HEADER
                Authorization: Bearer <token> 

        ANALYZE REQUESTS IN NETWORK
            LOGIN
                payload(client info sent to backend)
                response(backend to client)
            DASHBOARD
                header
                    Authorization: Bearer <token> 
                    response(backend to client)

        req.headers
            Gives back all the headers sent by the client's http request

        VERIFY TOKEN IN ROUTE 
            const decoded = jwt.verify(token, process.env.JWT_SECRET) 
            This is an async process, will throw error if token from front end is incorrect. 

        AUTH MIDDLEWARE SETUP
            Every single protected route will need the auth logic so this will become repetitive. To tackle this issue, lets refactor to a middleware this code. 

            EXAMPLE OF USING AUTH LOGIC AS MIDDLEWARE
                ROUTE
                    router.route('/dashboard').get(authenticationMiddleware, dashboard)
                
                AUTH MIDDLEWARE
                    const authenticationMiddleware = async (req, res, next) => {
                    //next here b/c we are not using another 3rd party middleware, we need to pass control to the next middleware.
                        console.log(req.headers.authorization)
                        next()
                    }
                    module.exports = authenticationMiddleware

        HTTP-STATUS-CODES
            The http-status-codes library is a Node.js package that provides a set of constants representing standard HTTP status codes and their descriptions. It simplifies working with HTTP status codes in your application by providing a more readable and maintainable way to reference them, rather than using numeric literals directly.

            INSTALL
                npm install http-status-codes

            EXAMPLE
                const { StatusCodes, ReasonPhrases } = require('http-status-codes');

                app.get('/', (req, res) => {
                    res.status(StatusCodes.OK).send(ReasonPhrases.OK); // Send "200 OK"
                });

            BENEFITS
                Readability: 
                    Using named constants like StatusCodes.OK or StatusCodes.BAD_REQUEST improves code readability and reduces the likelihood of errors compared to using raw numeric codes like 200 or 400.
                Maintainability: 
                    The code becomes easier to maintain since you don't have to remember what each numeric status code represents.
                Standardization: 
                    The library helps ensure you are using the correct status codes and reason phrases as defined by the HTTP specification.

        
SECTION 9: 06-JOBS API
THURSDAY
    WHAT TO LEARN
        1)combine auth knowledge with CRUD = api to log in and manage job search 
        2)deploy app to heroku to host app on the cloud
        3)setup nice doc with swagger UI
        
    LAST PROJECT WITH UI
        1)too time consuming
        2)Primarilly back end course 
        3)Use of swagger ui for docs instead

    FEATURES
        1)mini landing page
        2)register
        3)log in 
        4)CRUD of jobs
            a)Create a job in new job form 
            b)Read all created jobs
            c)Update a job on the edit job form 
            d)Delete a jobon the delete button
        5)Select - dropdown element for the status of each job:
            a)pending
            b)interview
            c)declined
        
    SETUP
        1)packages
        2)folders
        3).env
        4)connectDB
        5)errors
        6)middleware
    
    CONTROLLERS
        1)auth
            a)login
            b)register
        2)jobs
            a)CRUD 
    
    ROUTES
        1)/auth
        2)/jobs

    CONNECT DB 
        just set up variables and url

    USER MODELS 
        Whenever setting up models, several things have to be considered:

        THEORY TO REMEMBER
            What is a Schema?
                You can think of a Mongoose schema as the configuration object for a Mongoose model. 
                
            What is a Schema Type? 
                A SchemaType is then a configuration object for an individual property. 
                A SchemaType says what type a given path should have, whether it has any getters/setters, and what values are valid for that path.

        1)Validations
            Is defined in the schema type. 
            Is a middleware defined by a pre save hook on every schema by default. 
            
    REGISTER USER 
        Objectives: 
            - Validate - name, email, password - with Mongoose(done)
            - Hash Password (with bcryptjs)(done)
            - Save User(done)
            - Generate Token(done)
            - Send Response with Token(done)

        VALIDATE: NAME EMAIL PASSWORD

            EXAMPLE IN CONTROLLER
                const {name, email, password} = req.body
                if(!name || !email || !password) {
                    throw new BadRequestError('Please provide name, email, password') //our own logic errors take precedence over the default ones from mongoose
                }

            EXAMPLE IN MONGOOSE
                Include required or any other schemaTypes in those properties. 

        HASH PASSWORD 
            PROBLEM
                If someone hacks my database, they'll get access to everyones password...
            SOLUTION 
                Encryption.
        
            HASH PASSWORD WITH BCRYPT
                Hashing means generating random bytes and combining it with the password through a math algorithm that maps data of any size to a string of fixed size. 
                If anything changes, the whole string changes.

                HASHING VS ENCRYPTION
                    Hashing can't be reverted back unlike encryption.

                SALT
                    Random string added to the password before hashing. 
                    Ensure that if 1 users have same password, hashes will be different.

                HOW IT WORKS
                    Generate salt
                        Unique string added to passwords to ensure uniqueness
                        await bcrypt.genSalt(round)
                    Hash pass and salt
                        Pass and salt are combined, and run through the hash function
                    Store and hash together
                        The system will use both the hash and salt to verify passwords in the future
                        await bcrypt.hash(password, salt)
                    Verification
                        Bcrypt takes the salt from the stored hash, combines it with the provied password, runs the algorithm.
    
                WHERE TO HASH
                    1)controller
                    2)mongoose model middlware 

                MOVING HASH LOGIC TO MONGOOSE MODEL 
                    UserSchema.pre('save', async function(){
                        const salt = await bcrypt.genSalt(10)
                        this.password = await bcrypt.hash(this.password, salt) //we already have access to all the req.body, the Create function took care of that. 
                    })

            MONGOOSE MIDDLEWARE 
                Also called pre and post hooks, are functions executed during specific stages in a Mongoose model's lifecycle. 

                PURPOSE
                    Allows to perform DRY and efficient procedures before or after certain operations such as:
                        1)saving
                        2)deleting
                        3)querying
                
                COMMON USES
                    Add login to actions like:
                        1)validating data
                        2)hashing passwords
                        3)modifying documents before saving 
                THIS
                    When using pre middleware, "this" refers to the document itself or the query
                SYNTAX
                    const schema = new Schema(...)
                    Schema.pre/post('event', callbackFunction)

                RELATION TO OOP 
                    Similar to being able to configure your constructor function when creating an object. 
Monday
        GENERATE TOKEN
            IN CONTROLLER 
                const user = await User.create({...req.body})//req and sendig request to create document is first.
                const token = jwt.sign({userId: user._id, name: user.name}, process.env.JWT_SECRET, {expiresIn: '30d'})

            AS A MONGOOSE INSTANCE METHOD
                Are functions defined on mongoose model instances(documents) and can be used to perform operations on those specific documents. 

                WHY USEFUL?
                    Allow to encapsulate behavior that relates to the data within the document, allowing for organization of code. 

                RELATION TO OOP 
                    Similar to methods belonging to an object that perform operations based on the objects properties.

                EXAMPLE 
                    const mongoose = require('mongoose');

                    // Define a schema
                        const userSchema = new mongoose.Schema({
                            name: String,
                            email: String,
                            age: Number
                        });

                    // Define an instance method
                        userSchema.methods.getProfile = function() {
                            return `${this.name} (${this.email}) is ${this.age} years old.`;
                        };

                    // Create a model
                        const User = mongoose.model('User', userSchema);

                    // Example usage
                        async function example() {
                        // Create a new user instance
                            const user = new User({ name: 'Alice', email: 'alice@example.com', age: 30 });

                        // Call the instance method
                            console.log(user.getProfile()); // Output: Alice (alice@example.com) is 30 years old.
                        }

                    example();

                CREATING AN INSTANCE METHOD THAT WILL TAKE CARE OF GENERATING TOKEN WHEN USER IS CREATED
                    UserSchema.methods.createJWT = function () {
                        return jwt.sign({userId: this._id, name: this.name}, 'secret', {expiresIn: '30d'})
                    }

    LOGIN FUNCTIONALITY 
        Objectives:
            - Validate - email, password - in controller
            - If email or password is missing, throw BadRequestError
            - Find User
            - Compare Passwords
            - If no user or password does not match, throw UnauthenticatedError
            - If correct, generate Token
            - Send Response with Token
 
        EXAMPLE
            const login = async ( req, res ) => {
                const {email, password} = req.body

                if(!email || !password) {
                    throw new BadRequestError('Please provide email and password')
                }
                
                const user = await User.findOne({email}) //looks up the first 

                if(!user){
                    throw new UnauthenticatedError('No user with the email provided is registered in the database')
                }

                const isPasswordCorrect = await user.comparePassword(password)
                if(!isPasswordCorrect){
                    throw new UnauthenticatedError(`Password for email ${email} is incorrect`)
                }

                const token = user.createJWT()
                res.status(StatusCodes.OK).json({user: {name: user.name}, token}) //code for item found 200

            }

            module.exports = {
                register, login 
            }
Tuesday
    AUTH MIDDLEWARE SETUP 
        Objectives:
            - validate authorization presence and format 
            - no token provided throw error
            - get token from authHeader
            - extract payload from token 
            - insert payload into req
            - send data to next middleware

    JOBS MODEL 
        RELATIONSHIPS BETWEEN DOCUMENTS IN DIFFERENT COLLECTIONS 
            moongoose.Types.ObjectId
                In Mongoose, Types.ObjectId is a special type used to represent MongoDB Object IDs.
                Each document in a MongoDB collection has a unique identifier, which is usually an ObjectId. This ID is a 12-byte value, typically represented as a 24-character hexadecimal string.

            REF SchemaType
                ref: Establishes a relationship between collections.

            EXAMPLE
                // User schema
                const userSchema = new mongoose.Schema({
                    name: String,
                    email: String,
                });

                // Post schema
                const postSchema = new mongoose.Schema({
                    title: String,
                    content: String,
                    author: {
                        type: mongoose.Types.ObjectId,
                        ref: 'User',  // Reference to the User model
                    },
                });

Wednesday
    GET ALL JOBS
        USERID FILTER 
            Usually whatever the user receives will be filtered by his id, otherwise he would receive absolutely everything.

        EXAMPLE
            await Job.find({createdBy: userId}).sort('createdBy')

    SET TOKEN DYNAMICALLY IN POSTMAN
        Allows to run a script to automatically access the token received and send that to the routes that need it.

        AVOIDS
            The need to constantly copying and pasting the token in each and every route.

        ACCESS JSON DATA 
            const jsonData = pm.response.json()
        CREATE GLOBAL VARIABLE WITH THAT TOKEN
            pm.globals.set("accessToken", jsonData.token);
        AUTHORIZATION IN THE REST OF THE ROUTES
            {{accessToken}}

    GET SINGLE JOB 
        NESTED DESTRUCTURING
            const {user:{userId}, params:{id:jobId} } = req

    UPDATE JOB
        REMEMBER 
            path just modifies what you send instead of replacing the entire thing

        const job = await Job.findOneAndUpdate({_id: jobId, createdBy: userId}, req.body, {runValidators:true, new:true})

        ADD ADDITIONAL VALIDATION FOR COMPANY AND POSITION
            if(company === "" || position === ""){
                throw new BadRequestError('Company or Position fields cannot be empty')
            }

Thursday        
    ERRORS
        Objective:
            Make default mongoose errors more user friendly:
                - duplicate error(emails?)
                - custom errors
                - validation errros
                - cast errrors (id does not match exactly mongoose looking for)

        DUPLICATE
            Custom tailor through logic the errors already given by mongoose.

            EXAMPLE 
                let customError = {
                    //set default 
                    statusCode: err.statusCode || StatusCodes.INTERNAL_SERVER_ERROR,
                    msg: err.message || 'Something went wrong try again later'
                }

                if(err.code && err.code == 11000){
                    customError.msg = `Duplicate value entered for ${err.errorResponse.keyValue.email} field, please choose another value.`
                    customError.statusCode = 400 //Bad Request
                }
        
        CUSTOM ERROR
            Tailor the customError object into something that will be used also by the custom error err object send to the error middleware.
            Since the customError object already had these properties, it does not affect at all.

            SYNTAX
                return res.status(customError.statusCode).json({msg: customError.msg})

        VALIDATION ERROR
            Mongoose has new property that combines all validation errors in a single string.

        CAST ERROR
            Pretty much the same processs

    SECURITY INFO AND PACKAGES
        Deploying to cloud = Thinking about security.

        SOLUTION
            Installing packages in NPM 

        HELMET
            Setup numerous http headers to avoid attacks. 
            
        CORS
            API Accessible from different domains.

            NOT HAVING CORS
                Won't be able to accesss files except on local. 

        XSS - CLEAN 
            Sanitizes the user input in:
                req.body 
                req.query
                req.params

            Allowing for protection against malicious code injection. 

        EXPRESS-RATE-LIMIT
            Limits number of requests at the same time. 

    DEPLOYMENT PROCESS
        PREP THE GITHUB REPO
            1)move the project to its own folder to avoid any errors
            2)delete the .git directory from a repository 
                COMMAND
                    RM - RF .GIT(MAC AND LINUX)
                    rmdir /s /q .git(BASH)
                        rmdir: This command is to remove directories
                        /s: this option deletes the directory and all of its ocntents
                        /q: this stands fro quiet mode, which deletes the directory without asking confiration.
                    Remove-Item -Recurse -Force .git(POWERSHELL)
                        Remove-Item: The cmdlet for removing files or directories in PowerShell.
                        -Recurse: Deletes all items in the directory, including subdirectories and files.
                        -Force: Forces the removal without asking for confirmation, even for hidden or read-only files.
                        .git: The directory you want to remove.

                WHAT HAPPENS WHEN RUNNING THIS COMMAND
                    Complettely removes the .git directory from your project CAUSING a loss in version history and all git related configuration.
                    Eseentially converts to standard directory.

                WHY WOULD WE DO THIS 
                    Creating a New Repository  
                        If you want to make a fresh copy of the project for a different repository (without carrying over the original Git history), you can delete the .git directory and then initialize a new repository using git init

        RENDER
            1)connect github account to render
            2)select repository 
            3)start command: node app.js
            4)fix script in package.json file 
            5)import env variables 
            6)dummy route for testing

        POSTMAN
            1)create a global variable for the production domain.
            2)setup some route testing to confirm the deployment is working.
            
        POSTMAN DOCS
            Postman offers docs for API but it goes to a separate URL, we can't specify where we want for it to go.

            Export documentation from existing project collection.

        APIMATIC
            Helps devs automate the process of API docs.  

            PROBLEM
                Can't pass info directly to Swagger from Postman, it needs to be formatted by Apimatic.
            
            SDK Generation: 
                APIMatic allows the automatic creation of SDKs for different programming languages such as Python, Java, JavaScript, Ruby, etc., based on API specifications.
            API Documentation: 
                It helps generate rich, interactive API documentation automatically from API specifications. This documentation is easy to share with developers and can be easily integrated into other platforms.
            Code Samples: 
                APIMatic also generates code samples that show developers how to make calls to the API in different languages.
            API Specification Conversion: 
                It supports converting API specifications between different formats like Swagger (OpenAPI), RAML, API Blueprint, Postman collections, etc.
            Consistency and Updates: 
                Automatically keeps SDKs, code samples, and documentation up to date as the API evolves.

            USEFULNESS WITH SWAGGER
                In essence, Swagger/OpenAPI defines the API structure, and APIMatic builds on top of it by providing essential developer tools like SDKs, documentation, and code snippets to make the API more accessible to developers.

            STEPS TO USE
                1)import postman collection
                2)modify url
                3)make sure authentication is bearer token 
                4)change the endpoints from the group they are located in 
                5)export file as yaml 3.0
                6)paste in swagger editor
                        
        SWAGGER
            1)delete group not needed
            2)fix static url param to a dynamic one through the docs
            3)create swagger.yaml file in root of the repo pasting what was in swagger editor

            PACKAGES
                "swagger-ui-express": "^5.0.1",
                "yamljs": "^0.3.0"

            //swagger 
                const swaggerUI = require('swagger-ui-express') //imports the swagger ui 
                const YAML = require('yamljs') //imports the parser 
                const swaggerDocument= YAML.load('./swagger.yaml') //loads the yaml file

            //dummy route
                app.get('/', (req, res) => {
                res.send('<h1>Jobs API</h1><a href="/api-docs">Dcoumentation<a/>')
                })

                app.use('/api-docs', swaggerUI.serve, swaggerUI.setup(swaggerDocument))

SECTION 10: 07-JOBSTER-APP
    ABOUT
        Jobs api but taken to a much higher level 

Wednesday
    SPRING CLEANING
        REMOVE SWAGGER CODE
            1)app.js
            2)swagger.yaml
            3)procfile
        REMOVE RATE LIMITER
            1)app.js 
        REMOVE CORS
            1)only used when working with a backend
            2)if front end, only our front end should interact with our backend
        
    CLIENT
        PUBLIC
            Remember that static assets to serve will always go in the public folder.
                1)css files
                2)js files
                3)photos

    SETUP FRONT END
        Client side router(create react app) in development
            1)CRA offers a dev server which handles ALL ROUTING, no need to use own server.
            2)CRA intercepts every URL change without ever needing to ask the server.

            HOW IT WORKS
                1)react route manages all routes
                2)server provided by CRA serves the front end and refreshes the app
                
        Client side routing in production(built app)
            1)Moving react app into production with npm run build, the static files are generated and packaged.
            2)These files are then served by a server like EXPRESS, NGINX, or other static file host.
            3)The server needs to know how to serve the index.html file for any route. 
            4)server receives the request
            5)client side routing needs the index.html to be served
            6)catch all handler will serve the index.html and will let the client side routing handle the rest

        NPM RUN BUILD 
            Generatesd a React project with a standarized folder structure and pre configured settings.

            STRUCTURE INCLUDES:
                1)SRC: jsx files and other app logic
                2)PUBLIC: static assets like images and html templates
                3)node_modules: Contains all the dependencies installed for your project.
                4)package.json: List all dependencies nd defines scripts to run and build


    MODIFY USER MODEL 
        Add lastname and location properties
              lastName: {
                type: String, 
                trim: true,
                require: [true, "Please provide last name"],
                maxlength: 20,
                default: 'lastname'
            },
            location: {
                type:String,
                trim: true,
                default: 'my city'
            }
    
    MODIFY REGISTER AND LOGIN 
        With the purpose of sending a more complete response.

        const register = async (req, res) => {
        const user = await User.create({ ...req.body })
        const token = user.createJWT()
        res.status(StatusCodes.CREATED).json({user: {
            name: user.name,
            lastName: user.lastName,
            email:user.email,
            location: user.location,
            token
        }})
        }
        
    CREATE TEST USER
        Register with the credentials of a test user to automate the demo.

    UPDATE USER 
        Create controller with logic

        const updateUser = async(req, res) => {
        //destructure request
        const {email, name, lastName, location} = req.body
        //validate all values where provided 
        if(!email || !name || !lastName || !location) {
            throw new BadRequestError('Please provide all values')
        }
        //update user
        const user = await User.findByIdAndUpdate({_id: req.user.userId}, req.body, { new: true, runValidators: true })
        //generate token 
        const token = user.createJWT()
        res.status(StatusCodes.OK).json({user: {
            name: user.name,
            lastName: user.lastName,
            email:user.email,
            location: user.location,
            token
        }})
        }

        We send new token when the change could change

    USING SAVE WHEN UPDATING USER()
        Triggers the pre and post save hooks 


JOBSTER IS GOING TO BE LEFT UNFINISHED, WILL PROCEDE WITH OTHER MODULES 

QUICK GITHUB RECAP 

WORKING DIRECTORY 
    Directory available in the users computer file system where the changes in the files of the project are being made.

    .GIT DIRECTORY 
        After typing the command .git init, git behind the scenes, creates a special git database to store all info it needs to provide version control for the project.

        STAGING AREA (selecting for future operation)
            WHAT IS IT?        
                Intermediary where files make a pit stop first. 

            Git add will move the files to the staging area and will allow git to know which files have been changed and which changes have been made.

        GIT REPOSITORY  
            WHAT IS IT?
                database itself, object database. 

            Git commit will move from git staging area to git repository.
            Contains the files and history of changes made to the files. 

GIT FILE STATES
    COMMITED
        File is being tracked and safely stored in the repository.

    MODIFIED
        Changed since last time git took a photo of it. Different from version git has stored in repo.

    STAGED(selecting for future operation)
        Marked for inclution into next snapshot. 

GIT COMMANDS
    GIT CLONE
        From remote repository to local git repository

    GIT PULL 
        GIT FETCH
            From remote git repo to local git repo
        GIT MERGE
            Merge from local git repo to working directory

    GIT ADD 
        From working directory to staging area

    GIT COMMIT 
        From staging area to local repository 
    
    GIT PUSH 
        From local repository to remote repository

    GIT CHECKOUT / GIT SWITCH
        Switch from branches 

    
SECTION 11: HOW TO UPLOAD FILES TO A SERVER 

OBJECTIVES:
    Learn how to upload files to a server
    Reference to use before big project
    Learn to upload images using postman

TOOLS TO USE
    Express file upload library 
    Cloudinary service option (store images on the cloud)

EXAMPLE OF USE
    Admin of ecommerce store with form to add product. 
    Before adding product to database, image needs to be uploaded to server to make use of that path.

TUESDAY 12/4
    Setup
    Created product model
    Worked product controller
    Worked uploadsController
    Created productRouter
    Included on the app.js

WEDNESDAY 12/5 
---
CREATING A PRODUCT
    To create a product, image property will need a string that is a path to an uploaded image on the cloud.

    UPLOADING IMAGE TO CLOUD
        Another table in the db will hold the image name and path and that path will be given to the image property in the products table. 

    FLEXIBLE IMAGE MANAGEMENT
        Allows for one - many relationships if a product has multiple images.

    REUSABILITY
        If an image is relevant to more than one product, storing it in the images table avoids duplicating the same path for multiple products.

EXPRESS-FILEUPLOAD LIBRARY 
    PROBLEM
        When uploading a file through postman, express can't parse or understand it.

    WHAT IS IT?
        An easy to use middleware for processing file uploads in Express.js
        Parses incoming file data from multipart/form-data requests and makes uploaded files accessible through the req.files object

    WHY USE
        Ease of use
            Simplifes the upload by abstrascting complex parsing and file operations
        Flexibility
            Allows uploading files of various sizes
        Integration
            Works seemlessly
    
    HOW DOES IT WORK?
        Setup
            Intercepts and parses incoming multiport/form-data requests
        File Handling
            Uploaded files are attached to the req.files object
        File Operations
            Provides methods like .mv() to move or save the uploaded file to a specific directory 

    STEPS TO USE
        1)install
            npm i express-fileupload
        2)import
            const fileUpload = require('express-fileupload');

        3)use
            app.use(fileUpload());
            app.use(fileUpload({
                limits: { fileSize: 10 * 1024 * 1024 }, // 10MB limit
                abortOnLimit: true,                    // Reject files that exceed limit
                useTempFiles: true,                    // Use temporary files for uploads
                tempFileDir: '/tmp/'                   // Temp directory for storage
            }));
        
        4)handle file uploads in routes

MONDAY 09/12/24
GET ALL PRODUCTS CONTROLLER 
    Basic get controller to fetch all products from the db

WHY DONT WE NEED TO PROVIDE A FULL PATH?
    The front end is already pointing all the time to the server. So if we have the resources in the public folder, it will automatically look for the resources in that public folder.

HOW EXPRESS SERVES STATIC FILES 
    When we define a folder as "public" in an express app, using express.static, the files within the folder are automatically made accesible via HTTP. The express.static middleware serves these files relative to the specified directory. 

    WHAT HAPPENS INTERNALLY
        1)express maps that directory to the root path (/) of your app by default.
        2)Any file within the public folder can then be accessed directly by its relative path. 
        3)when using a url like "/uploads/burger.jpg", the browser automatically assumes that it's relative to your applications base URL.

ADDITIONAL CHECKS TO CHECK FOR:
    1)check if the image exists
    2)file sending is an image
    3)size is not bigger than specified 

CLOUDINARY 
    Cloud based service that provides tools for managing, storing, and optimizing media assets like images, videos, and other static files. 

    KEY FEATURES
        media storage
            stores your images, videos, and other files.
        image transformation
            on the fly transformations like resizing, cropping, and adding overlays to images via URL parameters.
        video processing
            supports video transformations like trimming or converting.
        cdn delivery
            delivers assets quickly through a content delivery network

CONNECTING TO MY CLOUDINARY 
    Setup 3 variables in the .env:
        CLOUD_NAME
        CLOUD_API_KEY
        CLOUD_API_SECRET

MONDAY 12/16/24 
    Finished section 07 file upload

TUESDAY 12/17/24
Start Section 08(11) Send Emails 

OBJECTIVE 
    1)Learn basics of email sending to build big API 
    2)Create route that will auto send an email to recipient 

NODEMAILER
    Nodejs library for sending emails programatically. 

    WHY?
        1)provides an easy way to set up and send emails from your app.
        2)supports plain text, html emails, file attachments.
        3)works with services like gmail, outlook, smtp servers.

    HOW?
        Requires a transport config to send emails. The transport defines how the emails is sent. (Typically through SMTP).
        1)install library
        2)configure a transport
        3)create and send email messages with transport

    CREATING TRANSPORT 
        Basically connecting to the service that does the sending.

    TRANSPORT SERVICE
        Ethereal 
        Mailtrap 
        Gmail 

    GOING FROM DEV TO PROD 
        Just swap credentials 

WEDNESDAY 12/18/24
Start section 09(12)-stripe


        






    


    


            
        
        

    
                    
                    

 




            

            








            
            
            

        

        


            








        

        

                


            

                

                

        
                        
        

    
        
    

        

        
            

                    
            
            
            


        




    
            
                    

        



        
        
        
        
        


    

        





        

    
        
            
            

        


            
                    
        


        

        
        
            
        

        

            

            


                


        

    
    
    
        



    
        
                    

    
    


    
                

            



            





        





    


    
-->